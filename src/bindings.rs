/* automatically generated by rust-bindgen */

pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __uint64_t = libc::c_ulonglong;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_time_t = libc::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type wchar_t = __darwin_wchar_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: __uint64_t,
    pub d_seekoff: __uint64_t,
    pub d_reclen: __uint16_t,
    pub d_namlen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_name: [libc::c_char; 1024usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::core::mem::size_of::<dirent>(),
        1048usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::core::mem::align_of::<dirent>(),
        8usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_seekoff as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_seekoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_namlen as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dirent>())).d_name as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DIR {
    pub __dd_fd: libc::c_int,
    pub __dd_loc: libc::c_long,
    pub __dd_size: libc::c_long,
    pub __dd_buf: *mut libc::c_char,
    pub __dd_len: libc::c_int,
    pub __dd_seek: libc::c_long,
    pub __padding: libc::c_long,
    pub __dd_flags: libc::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    assert_eq!(
        ::core::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::core::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_loc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__padding as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<DIR>())).__dd_td as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_td)
        )
    );
}
extern "C" {
    pub fn mz_path_combine(
        path: *mut libc::c_char,
        join: *const libc::c_char,
        max_path: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_path_append_slash(path: *mut libc::c_char, max_path: i32, slash: libc::c_char)
        -> i32;
}
extern "C" {
    pub fn mz_path_remove_slash(path: *mut libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_has_slash(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_convert_slashes(path: *mut libc::c_char, slash: libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_compare_wc(
        path: *const libc::c_char,
        wildcard: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_path_resolve(
        path: *const libc::c_char,
        target: *mut libc::c_char,
        max_target: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_path_remove_filename(path: *mut libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_remove_extension(path: *mut libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_path_get_filename(
        path: *const libc::c_char,
        filename: *mut *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_dir_make(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_file_get_crc(path: *const libc::c_char, result_crc: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_os_unicode_string_create(string: *const libc::c_char, encoding: i32) -> *mut wchar_t;
}
extern "C" {
    pub fn mz_os_unicode_string_delete(string: *mut *mut wchar_t);
}
extern "C" {
    pub fn mz_os_utf8_string_create(string: *const libc::c_char, encoding: i32) -> *mut u8;
}
extern "C" {
    pub fn mz_os_utf8_string_delete(string: *mut *mut u8);
}
extern "C" {
    pub fn mz_os_rand(buf: *mut u8, size: i32) -> i32;
}
extern "C" {
    pub fn mz_os_rename(source_path: *const libc::c_char, target_path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_unlink(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_file_exists(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_get_file_size(path: *const libc::c_char) -> i64;
}
extern "C" {
    pub fn mz_os_get_file_date(
        path: *const libc::c_char,
        modified_date: *mut time_t,
        accessed_date: *mut time_t,
        creation_date: *mut time_t,
    ) -> i32;
}
extern "C" {
    pub fn mz_os_set_file_date(
        path: *const libc::c_char,
        modified_date: time_t,
        accessed_date: time_t,
        creation_date: time_t,
    ) -> i32;
}
extern "C" {
    pub fn mz_os_get_file_attribs(path: *const libc::c_char, attributes: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_os_set_file_attribs(path: *const libc::c_char, attributes: u32) -> i32;
}
extern "C" {
    pub fn mz_os_make_dir(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_open_dir(path: *const libc::c_char) -> *mut DIR;
}
extern "C" {
    pub fn mz_os_read_dir(dir: *mut DIR) -> *mut dirent;
}
extern "C" {
    pub fn mz_os_close_dir(dir: *mut DIR) -> i32;
}
extern "C" {
    pub fn mz_os_is_dir(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_is_symlink(path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_make_symlink(path: *const libc::c_char, target_path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_os_read_symlink(
        path: *const libc::c_char,
        target_path: *mut libc::c_char,
        max_target_path: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_os_ms_time() -> u64;
}
pub type mz_stream_open_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, path: *const libc::c_char, mode: i32) -> i32,
>;
pub type mz_stream_is_open_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i32>;
pub type mz_stream_read_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, buf: *mut libc::c_void, size: i32) -> i32,
>;
pub type mz_stream_write_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, buf: *const libc::c_void, size: i32) -> i32,
>;
pub type mz_stream_tell_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i64>;
pub type mz_stream_seek_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32,
>;
pub type mz_stream_close_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i32>;
pub type mz_stream_error_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut libc::c_void) -> i32>;
pub type mz_stream_create_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut *mut libc::c_void) -> *mut libc::c_void,
>;
pub type mz_stream_destroy_cb =
    ::core::option::Option<unsafe extern "C" fn(stream: *mut *mut libc::c_void)>;
pub type mz_stream_get_prop_int64_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, prop: i32, value: *mut i64) -> i32,
>;
pub type mz_stream_set_prop_int64_cb = ::core::option::Option<
    unsafe extern "C" fn(stream: *mut libc::c_void, prop: i32, value: i64) -> i32,
>;
pub type mz_stream_find_cb = ::core::option::Option<
    unsafe extern "C" fn(
        stream: *mut libc::c_void,
        find: *const libc::c_void,
        find_size: i32,
        max_seek: i64,
        position: *mut i64,
    ) -> i32,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mz_stream_vtbl_s {
    pub open: mz_stream_open_cb,
    pub is_open: mz_stream_is_open_cb,
    pub read: mz_stream_read_cb,
    pub write: mz_stream_write_cb,
    pub tell: mz_stream_tell_cb,
    pub seek: mz_stream_seek_cb,
    pub close: mz_stream_close_cb,
    pub error: mz_stream_error_cb,
    pub create: mz_stream_create_cb,
    pub destroy: mz_stream_destroy_cb,
    pub get_prop_int64: mz_stream_get_prop_int64_cb,
    pub set_prop_int64: mz_stream_set_prop_int64_cb,
}
#[test]
fn bindgen_test_layout_mz_stream_vtbl_s() {
    assert_eq!(
        ::core::mem::size_of::<mz_stream_vtbl_s>(),
        96usize,
        concat!("Size of: ", stringify!(mz_stream_vtbl_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mz_stream_vtbl_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mz_stream_vtbl_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).open as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).is_open as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(is_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).read as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).write as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).tell as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).close as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).error as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).create as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_vtbl_s>())).destroy as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mz_stream_vtbl_s>())).get_prop_int64 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(get_prop_int64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mz_stream_vtbl_s>())).set_prop_int64 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_vtbl_s),
            "::",
            stringify!(set_prop_int64)
        )
    );
}
pub type mz_stream_vtbl = mz_stream_vtbl_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mz_stream_s {
    pub vtbl: *mut mz_stream_vtbl,
    pub base: *mut mz_stream_s,
}
#[test]
fn bindgen_test_layout_mz_stream_s() {
    assert_eq!(
        ::core::mem::size_of::<mz_stream_s>(),
        16usize,
        concat!("Size of: ", stringify!(mz_stream_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mz_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mz_stream_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_s>())).vtbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_s),
            "::",
            stringify!(vtbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_stream_s>())).base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_stream_s),
            "::",
            stringify!(base)
        )
    );
}
pub type mz_stream = mz_stream_s;
extern "C" {
    pub fn mz_stream_open(stream: *mut libc::c_void, path: *const libc::c_char, mode: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_read(stream: *mut libc::c_void, buf: *mut libc::c_void, size: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint8(stream: *mut libc::c_void, value: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint16(stream: *mut libc::c_void, value: *mut u16) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint32(stream: *mut libc::c_void, value: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_stream_read_int64(stream: *mut libc::c_void, value: *mut i64) -> i32;
}
extern "C" {
    pub fn mz_stream_read_uint64(stream: *mut libc::c_void, value: *mut u64) -> i32;
}
extern "C" {
    pub fn mz_stream_write(stream: *mut libc::c_void, buf: *const libc::c_void, size: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint8(stream: *mut libc::c_void, value: u8) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint16(stream: *mut libc::c_void, value: u16) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint32(stream: *mut libc::c_void, value: u32) -> i32;
}
extern "C" {
    pub fn mz_stream_write_int64(stream: *mut libc::c_void, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_write_uint64(stream: *mut libc::c_void, value: u64) -> i32;
}
extern "C" {
    pub fn mz_stream_copy(target: *mut libc::c_void, source: *mut libc::c_void, len: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_copy_to_end(target: *mut libc::c_void, source: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_copy_stream(
        target: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
        source: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_copy_stream_to_end(
        target: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
        source: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_find(
        stream: *mut libc::c_void,
        find: *const libc::c_void,
        find_size: i32,
        max_seek: i64,
        position: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_find_reverse(
        stream: *mut libc::c_void,
        find: *const libc::c_void,
        find_size: i32,
        max_seek: i64,
        position: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_set_base(stream: *mut libc::c_void, base: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_get_interface(stream: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_get_prop_int64(stream: *mut libc::c_void, prop: i32, value: *mut i64) -> i32;
}
extern "C" {
    pub fn mz_stream_set_prop_int64(stream: *mut libc::c_void, prop: i32, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_create(
        stream: *mut *mut libc::c_void,
        vtbl: *mut mz_stream_vtbl,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_raw_open(
        stream: *mut libc::c_void,
        filename: *const libc::c_char,
        mode: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_read(stream: *mut libc::c_void, buf: *mut libc::c_void, size: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_write(
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_raw_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_get_prop_int64(
        stream: *mut libc::c_void,
        prop: i32,
        value: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_set_prop_int64(stream: *mut libc::c_void, prop: i32, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_raw_create(stream: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_raw_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_buffered_open(
        stream: *mut libc::c_void,
        path: *const libc::c_char,
        mode: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_read(
        stream: *mut libc::c_void,
        buf: *mut libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_write(
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_buffered_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_buffered_create(stream: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_buffered_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_buffered_get_interface() -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_split_open(
        stream: *mut libc::c_void,
        filename: *const libc::c_char,
        mode: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_is_open(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_split_read(
        stream: *mut libc::c_void,
        buf: *mut libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_write(
        stream: *mut libc::c_void,
        buf: *const libc::c_void,
        size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_tell(stream: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_stream_split_seek(stream: *mut libc::c_void, offset: i64, origin: i32) -> i32;
}
extern "C" {
    pub fn mz_stream_split_close(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_split_error(stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_stream_split_get_prop_int64(
        stream: *mut libc::c_void,
        prop: i32,
        value: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_stream_split_set_prop_int64(stream: *mut libc::c_void, prop: i32, value: i64) -> i32;
}
extern "C" {
    pub fn mz_stream_split_create(stream: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_stream_split_delete(stream: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_stream_split_get_interface() -> *mut libc::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mz_zip_file_s {
    pub version_madeby: u16,
    pub version_needed: u16,
    pub flag: u16,
    pub compression_method: u16,
    pub modified_date: time_t,
    pub accessed_date: time_t,
    pub creation_date: time_t,
    pub crc: u32,
    pub compressed_size: i64,
    pub uncompressed_size: i64,
    pub filename_size: u16,
    pub extrafield_size: u16,
    pub comment_size: u16,
    pub disk_number: u32,
    pub disk_offset: i64,
    pub internal_fa: u16,
    pub external_fa: u32,
    pub filename: *const libc::c_char,
    pub extrafield: *const u8,
    pub comment: *const libc::c_char,
    pub linkname: *const libc::c_char,
    pub zip64: u16,
    pub aes_version: u16,
    pub aes_encryption_mode: u8,
}
#[test]
fn bindgen_test_layout_mz_zip_file_s() {
    assert_eq!(
        ::core::mem::size_of::<mz_zip_file_s>(),
        128usize,
        concat!("Size of: ", stringify!(mz_zip_file_s))
    );
    assert_eq!(
        ::core::mem::align_of::<mz_zip_file_s>(),
        8usize,
        concat!("Alignment of ", stringify!(mz_zip_file_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).version_madeby as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(version_madeby)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).version_needed as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(version_needed)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).flag as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mz_zip_file_s>())).compression_method as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(compression_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).modified_date as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(modified_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).accessed_date as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(accessed_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).creation_date as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(creation_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).crc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(crc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).compressed_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(compressed_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mz_zip_file_s>())).uncompressed_size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(uncompressed_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).filename_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(filename_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).extrafield_size as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(extrafield_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).comment_size as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(comment_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).disk_number as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(disk_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).disk_offset as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(disk_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).internal_fa as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(internal_fa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).external_fa as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(external_fa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).filename as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).extrafield as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(extrafield)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).comment as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).linkname as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(linkname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).zip64 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(zip64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mz_zip_file_s>())).aes_version as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(aes_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<mz_zip_file_s>())).aes_encryption_mode as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(mz_zip_file_s),
            "::",
            stringify!(aes_encryption_mode)
        )
    );
}
pub type mz_zip_file = mz_zip_file_s;
pub type mz_zip_entry = mz_zip_file_s;
pub type mz_zip_locate_entry_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
    ) -> i32,
>;
extern "C" {
    pub fn mz_zip_create(handle: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_zip_delete(handle: *mut *mut libc::c_void);
}
extern "C" {
    pub fn mz_zip_open(handle: *mut libc::c_void, stream: *mut libc::c_void, mode: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_get_comment(handle: *mut libc::c_void, comment: *mut *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_zip_set_comment(handle: *mut libc::c_void, comment: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_zip_get_version_madeby(handle: *mut libc::c_void, version_madeby: *mut u16) -> i32;
}
extern "C" {
    pub fn mz_zip_set_version_madeby(handle: *mut libc::c_void, version_madeby: u16) -> i32;
}
extern "C" {
    pub fn mz_zip_set_recover(handle: *mut libc::c_void, recover: u8) -> i32;
}
extern "C" {
    pub fn mz_zip_get_stream(handle: *mut libc::c_void, stream: *mut *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_set_cd_stream(
        handle: *mut libc::c_void,
        cd_start_pos: i64,
        cd_stream: *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_cd_mem_stream(
        handle: *mut libc::c_void,
        cd_mem_stream: *mut *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_is_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_read_open(
        handle: *mut libc::c_void,
        raw: u8,
        password: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_read(handle: *mut libc::c_void, buf: *mut libc::c_void, len: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_read_close(
        handle: *mut libc::c_void,
        crc32: *mut u32,
        compressed_size: *mut i64,
        uncompressed_size: *mut i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_write_open(
        handle: *mut libc::c_void,
        file_info: *const mz_zip_file,
        compress_level: i16,
        raw: u8,
        password: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_write(handle: *mut libc::c_void, buf: *const libc::c_void, len: i32)
        -> i32;
}
extern "C" {
    pub fn mz_zip_entry_write_close(
        handle: *mut libc::c_void,
        crc32: u32,
        compressed_size: i64,
        uncompressed_size: i64,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_is_dir(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_is_symlink(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_get_info(
        handle: *mut libc::c_void,
        file_info: *mut *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_get_local_info(
        handle: *mut libc::c_void,
        local_file_info: *mut *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_set_extrafield(
        handle: *mut libc::c_void,
        extrafield: *const u8,
        extrafield_size: u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_close_raw(
        handle: *mut libc::c_void,
        uncompressed_size: i64,
        crc32: u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_entry_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_set_number_entry(handle: *mut libc::c_void, number_entry: u64) -> i32;
}
extern "C" {
    pub fn mz_zip_get_number_entry(handle: *mut libc::c_void, number_entry: *mut u64) -> i32;
}
extern "C" {
    pub fn mz_zip_set_disk_number_with_cd(
        handle: *mut libc::c_void,
        disk_number_with_cd: u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_disk_number_with_cd(
        handle: *mut libc::c_void,
        disk_number_with_cd: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_get_entry(handle: *mut libc::c_void) -> i64;
}
extern "C" {
    pub fn mz_zip_goto_entry(handle: *mut libc::c_void, cd_pos: i64) -> i32;
}
extern "C" {
    pub fn mz_zip_goto_first_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_goto_next_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_locate_entry(
        handle: *mut libc::c_void,
        filename: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_locate_first_entry(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_locate_entry_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_locate_next_entry(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_locate_entry_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_is_dir(attrib: u32, version_madeby: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_is_symlink(attrib: u32, version_madeby: i32) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_convert(
        src_sys: u8,
        src_attrib: u32,
        target_sys: u8,
        target_attrib: *mut u32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_posix_to_win32(posix_attrib: u32, win32_attrib: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_zip_attrib_win32_to_posix(win32_attrib: u32, posix_attrib: *mut u32) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_find(stream: *mut libc::c_void, type_: u16, length: *mut u16) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_contains(
        extrafield: *const u8,
        extrafield_size: i32,
        type_: u16,
        length: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_read(
        stream: *mut libc::c_void,
        type_: *mut u16,
        length: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_extrafield_write(stream: *mut libc::c_void, type_: u16, length: u16) -> i32;
}
extern "C" {
    pub fn mz_zip_dosdate_to_tm(dos_date: u64, ptm: *mut tm) -> i32;
}
extern "C" {
    pub fn mz_zip_dosdate_to_time_t(dos_date: u64) -> time_t;
}
extern "C" {
    pub fn mz_zip_time_t_to_tm(unix_time: time_t, ptm: *mut tm) -> i32;
}
extern "C" {
    pub fn mz_zip_time_t_to_dos_date(unix_time: time_t) -> u32;
}
extern "C" {
    pub fn mz_zip_tm_to_dosdate(ptm: *const tm) -> u32;
}
extern "C" {
    pub fn mz_zip_ntfs_to_unix_time(ntfs_time: u64, unix_time: *mut time_t) -> i32;
}
extern "C" {
    pub fn mz_zip_unix_to_ntfs_time(unix_time: time_t, ntfs_time: *mut u64) -> i32;
}
extern "C" {
    pub fn mz_zip_path_compare(
        path1: *const libc::c_char,
        path2: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
pub type mz_zip_reader_overwrite_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        path: *const libc::c_char,
    ) -> i32,
>;
pub type mz_zip_reader_password_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        password: *mut libc::c_char,
        max_password: i32,
    ) -> i32,
>;
pub type mz_zip_reader_progress_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        position: i64,
    ) -> i32,
>;
pub type mz_zip_reader_entry_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        path: *const libc::c_char,
    ) -> i32,
>;
extern "C" {
    pub fn mz_zip_reader_is_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open(handle: *mut libc::c_void, stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open_file(handle: *mut libc::c_void, path: *const libc::c_char) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open_file_in_memory(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_open_buffer(
        handle: *mut libc::c_void,
        buf: *mut u8,
        len: i32,
        copy: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_unzip_cd(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_goto_first_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_goto_next_entry(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_locate_entry(
        handle: *mut libc::c_void,
        filename: *const libc::c_char,
        ignore_case: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_read(
        handle: *mut libc::c_void,
        buf: *mut libc::c_void,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_has_sign(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_sign_verify(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_get_hash(
        handle: *mut libc::c_void,
        algorithm: u16,
        digest: *mut u8,
        digest_size: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_get_first_hash(
        handle: *mut libc::c_void,
        algorithm: *mut u16,
        digest_size: *mut u16,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_get_info(
        handle: *mut libc::c_void,
        file_info: *mut *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_is_dir(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_process(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        write_cb: mz_stream_write_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_file(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_buffer(
        handle: *mut libc::c_void,
        buf: *mut libc::c_void,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_entry_save_buffer_length(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_save_all(
        handle: *mut libc::c_void,
        destination_dir: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_set_pattern(
        handle: *mut libc::c_void,
        pattern: *const libc::c_char,
        ignore_case: u8,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_password(handle: *mut libc::c_void, password: *const libc::c_char);
}
extern "C" {
    pub fn mz_zip_reader_set_raw(handle: *mut libc::c_void, raw: u8);
}
extern "C" {
    pub fn mz_zip_reader_get_raw(handle: *mut libc::c_void, raw: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_get_zip_cd(handle: *mut libc::c_void, zip_cd: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_get_comment(
        handle: *mut libc::c_void,
        comment: *mut *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_set_encoding(handle: *mut libc::c_void, encoding: i32);
}
extern "C" {
    pub fn mz_zip_reader_set_sign_required(handle: *mut libc::c_void, sign_required: u8);
}
extern "C" {
    pub fn mz_zip_reader_set_overwrite_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_overwrite_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_password_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_password_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_progress_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_progress_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_set_progress_interval(handle: *mut libc::c_void, milliseconds: u32);
}
extern "C" {
    pub fn mz_zip_reader_set_entry_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_reader_entry_cb,
    );
}
extern "C" {
    pub fn mz_zip_reader_get_zip_handle(
        handle: *mut libc::c_void,
        zip_handle: *mut *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_reader_create(handle: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_zip_reader_delete(handle: *mut *mut libc::c_void);
}
pub type mz_zip_writer_overwrite_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32,
>;
pub type mz_zip_writer_password_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        password: *mut libc::c_char,
        max_password: i32,
    ) -> i32,
>;
pub type mz_zip_writer_progress_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
        position: i64,
    ) -> i32,
>;
pub type mz_zip_writer_entry_cb = ::core::option::Option<
    unsafe extern "C" fn(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        file_info: *mut mz_zip_file,
    ) -> i32,
>;
extern "C" {
    pub fn mz_zip_writer_is_open(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_open(handle: *mut libc::c_void, stream: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_open_file(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
        disk_size: i64,
        append: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_open_file_in_memory(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_zip_cd(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_open(handle: *mut libc::c_void, file_info: *mut mz_zip_file) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_close(handle: *mut libc::c_void) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_write(
        handle: *mut libc::c_void,
        buf: *const libc::c_void,
        len: i32,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_entry_sign(
        handle: *mut libc::c_void,
        message: *mut u8,
        message_size: i32,
        cert_data: *mut u8,
        cert_data_size: i32,
        cert_pwd: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_process(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_info(
        handle: *mut libc::c_void,
        stream: *mut libc::c_void,
        read_cb: mz_stream_read_cb,
        file_info: *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_buffer(
        handle: *mut libc::c_void,
        buf: *mut libc::c_void,
        len: i32,
        file_info: *mut mz_zip_file,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_file(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
        filename_in_zip: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_add_path(
        handle: *mut libc::c_void,
        path: *const libc::c_char,
        root_path: *const libc::c_char,
        include_path: u8,
        recursive: u8,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_copy_from_reader(
        handle: *mut libc::c_void,
        reader: *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_set_password(handle: *mut libc::c_void, password: *const libc::c_char);
}
extern "C" {
    pub fn mz_zip_writer_set_comment(handle: *mut libc::c_void, comment: *const libc::c_char);
}
extern "C" {
    pub fn mz_zip_writer_set_raw(handle: *mut libc::c_void, raw: u8);
}
extern "C" {
    pub fn mz_zip_writer_get_raw(handle: *mut libc::c_void, raw: *mut u8) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_set_aes(handle: *mut libc::c_void, aes: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_compress_method(handle: *mut libc::c_void, compress_method: u16);
}
extern "C" {
    pub fn mz_zip_writer_set_compress_level(handle: *mut libc::c_void, compress_level: i16);
}
extern "C" {
    pub fn mz_zip_writer_set_follow_links(handle: *mut libc::c_void, follow_links: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_store_links(handle: *mut libc::c_void, store_links: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_zip_cd(handle: *mut libc::c_void, zip_cd: u8);
}
extern "C" {
    pub fn mz_zip_writer_set_certificate(
        handle: *mut libc::c_void,
        cert_path: *const libc::c_char,
        cert_pwd: *const libc::c_char,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_set_overwrite_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_overwrite_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_set_password_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_password_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_set_progress_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_progress_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_set_progress_interval(handle: *mut libc::c_void, milliseconds: u32);
}
extern "C" {
    pub fn mz_zip_writer_set_entry_cb(
        handle: *mut libc::c_void,
        userdata: *mut libc::c_void,
        cb: mz_zip_writer_entry_cb,
    );
}
extern "C" {
    pub fn mz_zip_writer_get_zip_handle(
        handle: *mut libc::c_void,
        zip_handle: *mut *mut libc::c_void,
    ) -> i32;
}
extern "C" {
    pub fn mz_zip_writer_create(handle: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn mz_zip_writer_delete(handle: *mut *mut libc::c_void);
}
